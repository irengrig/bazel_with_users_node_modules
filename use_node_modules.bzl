def _generate_fine_grained_node_modules(rctx):
    print("-- fetch --")
    package_json_path = rctx.path(rctx.attr.package_json)

    result = cmd(rctx, "cd " + str(package_json_path.dirname) + " && npm install")

    node_modules_root = rctx.path(str(package_json_path) + "/../node_modules")
    build_file_lines = []
    for path_ in node_modules_root.readdir():
        name = path_.basename
        rctx.symlink(path_, rctx.path(name))
        build_file_lines += ["""filegroup(name = "{name}", srcs = glob(["{name}/**"]), visibility = ["//visibility:public"])""".format(name = name)]

    rctx.file("BUILD", "\n".join(build_file_lines))

def _needs_update(rctx):
#    print("-- needs-update --")
    package_json_path = rctx.path(rctx.attr.package_json)

#    result = cmd(rctx, "cd " + str(package_json_path.dirname) + " && npm install --dry-run")
# Unfortunately, npm install --dry-run takes lots of time (about 800 millis)
# So I wrote some other check code, really simple. This ensures that the package directory is there.
# Of course, it should be something more intelligent for production.
    files_to_check = ["/node_modules/simple-is"]
    needs_update = False
    root_ = str(package_json_path.dirname)
    for file in files_to_check:
        if not rctx.path(root_ + file).exists:
            print("Should be updated")
            return True

    print("Should not be updated")
    return False

generate_fine_grained_node_modules = repository_rule(
    implementation = _generate_fine_grained_node_modules,
    needs_update = _needs_update,
    attrs = {
        "package_json": attr.label(),
    },
)

def use_node_modules(package_json):
    generate_fine_grained_node_modules(
        name = "generated_node_modules",
        package_json = package_json,
    )

def cmd(
        repository_ctx,
        command,
        environment = None):
    """Execute a command, return stdout if succeed and throw an error if it fails. Doesn't escape the result!"""
    if environment:
        result = repository_ctx.execute(["bash", "-c", command], environment = environment)
    else:
        result = repository_ctx.execute(["bash", "-c", command])
    if result.return_code != 0:
        fail("non-zero exit code: %d, command %s, stderr: (%s)" % (
            result.return_code,
            command,
            result.stderr,
        ))
    stripped_stdout = result.stdout.strip()
    if not stripped_stdout:
        fail(
            "empty output from command %s, stderr: (%s)" % (command, result.stderr),
        )
    return stripped_stdout
