def _generate_fine_grained_node_modules(rctx):
    package_json_path = rctx.path(rctx.attr.package_json)
    node_modules_root = rctx.path(str(package_json_path) + "/../node_modules")

    result = cmd(rctx, "cd " + str(node_modules_root.dirname) + " && npm install")
    print(result)

    build_file_lines = []
    for path_ in node_modules_root.readdir():
        name = path_.basename
        rctx.symlink(path_, rctx.path(name))
        build_file_lines += ["""filegroup(name = "{name}", srcs = glob(["{name}/**"]), visibility = ["//visibility:public"])""".format(name = name)]

    rctx.file("BUILD", "\n".join(build_file_lines))

generate_fine_grained_node_modules = repository_rule(
    implementation = _generate_fine_grained_node_modules,
    attrs = {
        "package_json": attr.label(),
    },
    local = True,
)

def use_node_modules(package_json):
    generate_fine_grained_node_modules(
        name = "generated_node_modules",
        package_json = package_json,
    )

def cmd(
        repository_ctx,
        command,
        environment = None):
    """Execute a command, return stdout if succeed and throw an error if it fails. Doesn't escape the result!"""
    if environment:
        result = repository_ctx.execute(["bash", "-c", command], environment = environment)
    else:
        result = repository_ctx.execute(["bash", "-c", command])
    if result.return_code != 0:
        fail("non-zero exit code: %d, command %s, stderr: (%s)" % (
            result.return_code,
            command,
            result.stderr,
        ))
    stripped_stdout = result.stdout.strip()
    if not stripped_stdout:
        fail(
            "empty output from command %s, stderr: (%s)" % (command, result.stderr),
        )
    return stripped_stdout
